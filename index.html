<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>스포츠 커뮤니티 프로토타입</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* CSS는 이전과 동일합니다. */
        body { font-family: 'Noto Sans KR', sans-serif; background-color: #f1f5f9; color: #1e293b; display: flex; flex-direction: column; min-height: 100vh; margin: 0; }
        .container { width: 100%; max-width: 1280px; margin-left: auto; margin-right: auto; padding: 1rem; flex-grow: 1; }
        .view { display: none; }
        .view.active { display: block; }
        .header { display: flex; flex-direction: column; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 1px solid #e2e8f0; }
        .header h1 { font-size: 1.875rem; font-weight: 700; color: #1e293b; cursor: pointer; margin-bottom: 1rem; }
        .search-area { display: flex; align-items: center; gap: 0.5rem; width: 100%; }
        .search-area input { padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 0.5rem; width: 100%; }
        .search-area input:focus { outline: none; box-shadow: 0 0 0 2px #34d399; }
        .search-area button { padding: 0.5rem; background-color: #334155; color: white; border: none; border-radius: 0.5rem; cursor: pointer; }
        .search-area button:hover { background-color: #1e293b; }
        .user-menu { display: flex; gap: 1rem; margin-top: 1rem; align-items: center; }
        .user-menu span { font-weight: 500; }
        .user-menu a, .user-menu button { color: #475569; text-decoration: none; background: none; border: none; cursor: pointer; font-size: 1em; font-family: inherit; font-weight: 500; padding: 0;}
        .user-menu a:hover, .user-menu button:hover { color: #059669; }
        .main-nav { background-color: white; border-radius: 0.5rem; box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05); padding: 0.5rem; margin-bottom: 2rem; }
        .main-nav ul { display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 0.5rem; font-weight: 600; list-style: none; padding: 0; margin: 0; }
        .nav-link { padding: 0.75rem; display: block; color: #334155; border-radius: 0.5rem; text-decoration: none; cursor: pointer; }
        .nav-link:hover { background-color: #f1f5f9; }
        .nav-link.active { color: #059669; font-weight: 700; }
        .sports-gallery-menu { position: relative; }
        .sports-gallery-toggle { display: flex; align-items: center; }
        .sports-gallery-toggle svg { width: 1rem; height: 1rem; margin-left: 0.25rem; color: #64748b; }
        .sports-gallery-dropdown { position: absolute; display: none; margin-top: 0.5rem; width: 12rem; background-color: white; border-radius: 0.5rem; box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1); z-index: 10; border: 1px solid #f1f5f9; }
        .sports-gallery-dropdown.show { display: block; }
        .sports-gallery-dropdown .nav-link { font-size: 0.875rem; }
        main section { margin-bottom: 2.5rem; }
        main h2 { font-size: 1.5rem; font-weight: 700; margin-bottom: 1rem; }
        .match-schedule { display: grid; gap: 1rem; }
        .match-card { background-color: white; padding: 1rem; border-radius: 0.5rem; box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05); border: 1px solid #e2e8f0; }
        .match-card-header { display: flex; justify-content: space-between; align-items: center; font-size: 0.875rem; color: #64748b; margin-bottom: 0.5rem; }
        .match-card-header .status { font-weight: 700; }
        .match-card-header .status.live { color: #ef4444; }
        .match-card-header .status.finished { color: #64748b; }
        .match-card-body { display: flex; align-items: center; justify-content: space-around; }
        .match-card-body .team { font-weight: 700; font-size: 1.125rem; }
        .match-card-body .score { font-weight: 700; font-size: 1.5rem; }
        .popular-posts { background-color: white; padding: 1rem; border-radius: 0.5rem; box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05); }
        .popular-posts ul { list-style: none; padding: 0; margin: 0; }
        .popular-posts li { padding-top: 0.5rem; padding-bottom: 0.5rem; border-bottom: 1px solid #f1f5f9; }
        .popular-posts li:last-child { border-bottom: none; }
        .popular-posts a { text-decoration: none; color: inherit; }
        .popular-posts a:hover { color: #059669; }
        .popular-posts .board-name { font-weight: 600; color: #64748b; }
        .popular-posts .comment-count { font-weight: 600; color: #ef4444; }
        .photo-gallery { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 1rem; }
        .photo-card { border-radius: 0.5rem; overflow: hidden; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); cursor: pointer; }
        .photo-card img { width: 100%; height: 10rem; object-fit: cover; transition: transform 0.3s ease; }
        .photo-card:hover img { transform: scale(1.05); }
        .photo-card .caption { padding: 0.5rem; background-color: white; }
        .photo-card .caption p { font-size: 0.875rem; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .board-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
        .write-btn { background-color: #059669; color: white; padding: 0.5rem 1rem; border-radius: 0.5rem; font-weight: 600; border: none; cursor: pointer; }
        .write-btn:hover { background-color: #047857; }
        .table-container { background-color: white; border-radius: 0.5rem; box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05); overflow-x: auto; }
        .post-table { width: 100%; font-size: 0.875rem; text-align: left; color: #64748b; }
        .post-table thead { font-size: 0.75rem; color: #334155; text-transform: uppercase; background-color: #f8fafc; }
        .post-table th, .post-table td { padding: 0.75rem 1.5rem; }
        .post-table tbody tr { border-bottom: 1px solid #f1f5f9; }
        .post-table tbody tr:hover { background-color: #f8fafc; cursor: pointer; }
        .pagination { display: flex; justify-content: center; margin-top: 1rem; }
        .pagination button { padding: 0.25rem 0.75rem; margin: 0 0.25rem; border-radius: 0.5rem; border: 1px solid #cbd5e1; background-color: white; color: #334155; cursor: pointer; }
        .pagination button.active { background-color: #059669; color: white; border-color: #059669; }
        .modal-overlay { position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 50; }
        .modal-overlay.show { display: flex; }
        .modal-box { background-color: white; padding: 1.5rem; border-radius: 0.75rem; box-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25); width: 100%; max-width: 400px; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
        .modal-header h2 { font-size: 1.25rem; font-weight: 700; }
        .modal-close-btn { font-size: 1.5rem; color: #64748b; cursor: pointer; border: none; background: none; }
        .modal-close-btn:hover { color: #1e293b; }
        .modal-body .form-group { margin-bottom: 1rem; }
        .modal-body label { display: block; margin-bottom: 0.25rem; font-weight: 600; }
        .modal-body input { width: 100%; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 0.5rem; box-sizing: border-box; }
        .modal-body button { width: 100%; padding: 0.75rem; border-radius: 0.5rem; background-color: #059669; color: white; font-weight: 600; border: none; cursor: pointer; }
        .modal-body button:hover { background-color: #047857; }
        .footer { background-color: #1e293b; color: white; margin-top: 2rem; }
        .footer .container { padding: 1.5rem; text-align: center; font-size: 0.875rem; }
        .footer p { margin-bottom: 0.5rem; }
        .footer .links { display: flex; justify-content: center; gap: 1rem; margin-bottom: 0.5rem; }
        .footer a { color: white; text-decoration: none; }
        .footer a:hover { text-decoration: underline; }
        .footer .copyright { color: #94a3b8; }
        @media (min-width: 640px) { .header { flex-direction: row; } .header h1 { margin-bottom: 0; } .user-menu { margin-top: 0; } .main-nav ul { justify-content: flex-start; flex-wrap: nowrap; } .search-area { width: auto; } }
        @media (min-width: 768px) { .match-schedule { grid-template-columns: repeat(2, minmax(0, 1fr)); } .photo-gallery { grid-template-columns: repeat(4, minmax(0, 1fr)); } }
        @media (min-width: 1024px) { .match-schedule { grid-template-columns: repeat(3, minmax(0, 1fr)); } }
        /* 글쓰기 폼 스타일 */
        #write-form { padding: 1.5rem; background-color: white; border-radius: 0.5rem; box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05); }
        #write-form input, #write-form textarea { width: 100%; padding: 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.5rem; box-sizing: border-box; margin-bottom: 1rem; }
        #write-form textarea { min-height: 250px; resize: vertical; }
        #write-form .form-actions { text-align: right; }
        /* 게시물 보기 스타일 */
        #post-content-view { padding: 1.5rem; background-color: white; border-radius: 0.5rem; }
        #post-content-view h1 { font-size: 2rem; }
        #post-meta { color: #64748b; margin-bottom: 1.5rem; }
        #post-body { line-height: 1.8; min-height: 200px; border-top: 1px solid #e2e8f0; border-bottom: 1px solid #e2e8f0; padding: 2rem 0; }
        
        /* === 댓글 기능 CSS 추가 START === */

        #comments-section {
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px solid #e2e8f0;
        }

        #comments-section h3 {
            font-size: 1.25rem;
            margin-bottom: 1rem;
        }

        #comments-list {
            list-style: none;
            padding: 0;
        }

        .comment-item {
            padding: 1rem 0;
            border-bottom: 1px solid #f1f5f9;
        }
        .comment-item:last-child {
            border-bottom: none;
        }

        .comment-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.5rem;
        }

        .comment-author {
            font-weight: 700;
        }

        .comment-date {
            font-size: 0.875rem;
            color: #64748b;
        }

        .comment-body {
            margin-bottom: 0.5rem;
        }

        .comment-actions button {
            background: none;
            border: none;
            color: #64748b;
            font-size: 0.875rem;
            cursor: pointer;
            padding: 0.25rem;
        }
        .comment-actions button:hover {
            color: #059669;
        }

        /* 대댓글 스타일 */
        .reply-list {
            list-style: none;
            padding-left: 2.5rem; /* 대댓글 들여쓰기 */
            border-left: 2px solid #e2e8f0;
            margin-top: 1rem;
        }

        /* 댓글/답글 작성 폼 */
        .comment-form {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        .comment-form textarea {
            flex-grow: 1;
            border: 1px solid #cbd5e1;
            border-radius: 0.5rem;
            padding: 0.75rem;
            resize: vertical;
            min-height: 40px;
        }
        .comment-form button {
            flex-shrink: 0;
            height: 42px; /* textarea 높이와 맞춤 */
        }

        .reply-form-container {
            padding-left: 2.5rem;
            margin-top: 1rem;
        }

        /* === 댓글 기능 CSS 추가 END === */
   </style>
</head>
<body>

    <div id="app" class="container">
        
        <header class="header">
            <h1 id="logo">스포츠타운</h1>
            <div class="search-area">
                <input type="text" placeholder="통합 검색...">
                <button>검색</button>
            </div>
            <div id="user-menu-container" class="user-menu">
                </div>
        </header>

        <nav class="main-nav">
            <ul>
                <li><a href="#" class="nav-link" data-board="freeboard">자유게시판</a></li>
                <li class="sports-gallery-menu" id="sports-gallery-menu">
                    <a href="#" id="sports-gallery-toggle" class="nav-link sports-gallery-toggle" data-board-group="sports">
                        스포츠갤러리
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </a>
                    <div id="sports-gallery-dropdown" class="sports-gallery-dropdown">
                        <a href="#" class="nav-link" data-board="soccer">축구</a>
                        <a href="#" class="nav-link" data-board="baseball">야구</a>
                        <a href="#" class="nav-link" data-board="basketball">농구</a>
                        <a href="#" class="nav-link" data-board="esports">e스포츠</a>
                    </div>
                </li>
                <li><a href="#" class="nav-link" data-main-nav-link="true" data-board="announcements">공지사항</a></li>
            </ul>
        </nav>

        <main>
            <div id="main-view" class="view active">
                <section>
                    <h2>주요 경기</h2>
                    <div id="match-schedule" class="match-schedule"></div>
                </section>
                <section>
                    <h2>커뮤니티 인기글</h2>
                    <div id="popular-posts" class="popular-posts"></div>
                </section>
                <section>
    <h2>🤖 AI 승부 예측</h2>
    <div id="prediction-ui" style="background-color: white; padding: 1.5rem; border-radius: 0.5rem; box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);">
        <div style="display: flex; gap: 1rem; margin-bottom: 1rem; align-items: center; flex-wrap: wrap;">
            <select id="ai-sport-select" style="padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 0.5rem;">
                <option value="soccer">축구</option>
                <option value="baseball">야구</option>
                <option value="basketball">농구</option>
                <option value="esports">e스포츠</option>
            </select>
            <input type="text" id="ai-team-a" placeholder="팀 A 이름" style="flex-grow: 1; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 0.5rem;">
            <span style="font-weight: 700;">VS</span>
            <input type="text" id="ai-team-b" placeholder="팀 B 이름" style="flex-grow: 1; padding: 0.5rem; border: 1px solid #cbd5e1; border-radius: 0.5rem;">
            <button id="ai-predict-btn" class="write-btn">예측하기</button>
        </div>
        <div id="ai-prediction-result" style="margin-top: 1rem; padding: 1rem; border: 1px dashed #e2e8f0; border-radius: 0.5rem; min-height: 50px; white-space: pre-wrap; line-height: 1.6;">
            결과가 여기에 표시됩니다.
        </div>
    </div>
</section>
            </div>

            <div id="board-view" class="view">
                <div class="board-header">
                    <h2 id="board-title"></h2>
                    <button id="write-post-btn" class="write-btn">글쓰기</button>
                </div>
                <div class="table-container">
                    <table class="post-table">
                        <thead>
  <tr>
    <th>번호</th><th>제목</th><th>글쓴이</th><th>작성일</th><th>조회</th><th>추천</th><th>비추천</th>
  </tr>
</thead>
                        <tbody id="post-list"></tbody>
                    </table>
                </div>
                <div id="pagination" class="pagination"></div>
            </div>

            <div id="post-view" class="view">
                </div>

            <div id="write-view" class="view">
                </div>
        </main>
    </div>
    
    <div id="login-modal" class="modal-overlay">
        <div class="modal-box">
            <div class="modal-header"><h2>로그인</h2><button class="modal-close-btn">&times;</button></div>
            <div class="modal-body">
                <form id="login-form">
                    <div class="form-group"><label for="login-email">이메일</label><input type="email" id="login-email" required></div>
                    <div class="form-group"><label for="login-password">비밀번호</label><input type="password" id="login-password" required></div>
                    <button type="submit">로그인</button>
                </form>
            </div>
        </div>
    </div>
    <div id="signup-modal" class="modal-overlay">
        <div class="modal-box">
            <div class="modal-header"><h2>회원가입</h2><button class="modal-close-btn">&times;</button></div>
            <div class="modal-body">
               <form id="signup-form">
                    <div class="form-group"><label for="signup-nickname">닉네임</label><input type="text" id="signup-nickname" required></div>
                    <div class="form-group"><label for="signup-email">이메일</label><input type="email" id="signup-email" required></div>
                    <div class="form-group"><label for="signup-password">비밀번호</label><input type="password" id="signup-password" minlength="6" required></div>
                    <button type="submit">가입하기</button>
               </form>
            </div>
        </div>
    </div>

    <footer class="footer">
        <div class="container">
            <p style="font-weight: 700;">스포츠타운</p>
            <div class="links">
                <a href="#">회사소개</a><a href="#">이용약관</a><a href="#">개인정보처리방침</a><a href="#">고객센터</a>
            </div>
            <p class="copyright">© 2025 Sportstown. All Rights Reserved.</p>
        </div>
    </footer>

    <script type="module">
        // Firebase SDK IMPORTS
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { 
            getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, 
            onAuthStateChanged, signOut, updateProfile
        } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { 
  getFirestore, doc, setDoc, getDoc, getDocs, collection, 
  query, where, orderBy, limit, addDoc, serverTimestamp, increment, updateDoc,
  runTransaction // ✅ 추가
} from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // FIREBASE CONFIG
        const firebaseConfig = {
            apiKey: "AIzaSyAUuUlYHUwOuwnm_hsIsd7XHlj5voCecQk",
            authDomain: "community-d18d4.firebaseapp.com",
            projectId: "community-d18d4",
            storageBucket: "community-d18d4.appspot.com",
            messagingSenderId: "497702481194",
            appId: "1:497702481194:web:a826db91628adc24718253"
        };

        // FIREBASE INITIALIZATION
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // APP STATE
        const appState = {
            currentUser: null,
            currentView: 'main-view',
            currentBoard: null,
            currentPostId: null,
            currentPage: 1,
            postsPerPage: 10,
        };
        
        const boardNames = {
            freeboard: '자유게시판', announcements: '공지사항', soccer: '축구', 
            baseball: '야구', basketball: '농구', esports: 'e스포츠',
        };

        // === Firestore 데이터 로드 함수 ===
        
        async function fetchMatches() {
            const matchesCol = collection(db, 'matches');
            const q = query(matchesCol, orderBy('time', 'desc'), limit(6));
            const snapshot = await getDocs(q);
            return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        }
        
        async function fetchPopularPosts() {
            const postsCol = collection(db, 'posts');
            const q = query(postsCol, orderBy('likes', 'desc'), limit(5));
            const snapshot = await getDocs(q);
            return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        }

        async function fetchPostsForBoard(boardId, page = 1) {
            const postsCol = collection(db, 'posts');
            // 참고: Firestore 페이지네이션은 더 복잡하지만, 여기서는 최신 글 N개만 가져오는 방식으로 단순화
            const q = query(postsCol, where("board", "==", boardId), orderBy("createdAt", "desc"), limit(appState.postsPerPage));
            const snapshot = await getDocs(q);
            return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        }

        // === UI 렌더링 함수 ===

        function showView(viewId) {
            document.querySelectorAll('.view').forEach(view => view.classList.remove('active'));
            const viewToShow = document.getElementById(viewId);
            if(viewToShow) {
                viewToShow.classList.add('active');
                appState.currentView = viewId;
                window.scrollTo(0, 0);
            }
        }

        // 변경: Firestore에서 데이터를 비동기로 가져오도록 수정
        async function renderMainView() {
            showView('main-view');
            
            // 경기 정보 렌더링
            const matches = await fetchMatches();
            const matchContainer = document.getElementById('match-schedule');
            matchContainer.innerHTML = matches.map(match => `
                <div class="match-card">
                    <div class="match-card-header">
                        <span>${boardNames[match.sport] || match.sport}</span>
                        <span class="status ${match.time === '종료' ? 'finished' : 'live'}">${match.time}</span>
                    </div>
                    <div class="match-card-body">
                        <span class="team">${match.teamA}</span>
                        <span class="score">${match.scoreA} : ${match.scoreB}</span>
                        <span class="team">${match.teamB}</span>
                    </div>
                </div>
            `).join('') || "<p>등록된 경기가 없습니다.</p>";

    // 인기글 렌더링
    const popularPosts = await fetchPopularPosts();
    const popularPostsContainer = document.getElementById('popular-posts');
    popularPostsContainer.innerHTML = `<ul>${popularPosts.map(post => `
        <li>
            <a href="#" class="post-link" data-post-id="${post.id}" data-board="${post.board}">
                <span class="board-name">[${boardNames[post.board]}]</span> ${post.title} 
                <span class="comment-count">[${post.commentCount || 0}]</span>
            </a>
        </li>
    `).join('')}</ul>` || "<p>인기글이 없습니다.</p>";
        }


// === AI 승부 예측 기능 추가 START ===

async function handlePrediction(e) {
    const sport = document.getElementById('ai-sport-select').value;
    const teamA = document.getElementById('ai-team-a').value.trim();
    const teamB = document.getElementById('ai-team-b').value.trim();
    const resultDiv = document.getElementById('ai-prediction-result');
    const predictBtn = document.getElementById('ai-predict-btn');

    if (!teamA || !teamB) {
        alert('팀 이름을 모두 입력해주세요!');
        return;
    }

    // 로딩 상태 표시
    resultDiv.textContent = '🧠 AI가 열심히 분석 중입니다...';
    predictBtn.disabled = true;
    predictBtn.textContent = '분석중...';

    try {
        const response = await fetch('/api/predict', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ sport, teamA, teamB }),
        });

        const data = await response.json();

        if (!response.ok) {
            throw new Error(data.error || '알 수 없는 오류가 발생했습니다.');
        }

        resultDiv.textContent = data.prediction;

    } catch (error) {
        console.error('Prediction Error:', error);
        resultDiv.textContent = `오류 발생: ${error.message}`;
    } finally {
        // 로딩 상태 해제
        predictBtn.disabled = false;
        predictBtn.textContent = '예측하기';
    }
}

// 예측 버튼에 이벤트 리스너 연결
// 이 코드는 renderMainView 함수가 호출된 후에 실행되어야 하므로,
// 초기 렌더링 후 이벤트 리스너를 한 번만 추가해줍니다.
document.addEventListener('DOMContentLoaded', () => {
    // 버튼이 나중에 생성될 수 있으므로 상위 요소에 이벤트 위임을 사용합니다.
    document.body.addEventListener('click', function(event) {
        if (event.target && event.target.id === 'ai-predict-btn') {
            handlePrediction();
        }
    });
});



        
        // 변경: Firestore에서 데이터를 비동기로 가져오도록 수정
        async function renderBoardView(boardId, page) {
  appState.currentBoard = boardId;
  appState.currentPage = page;
  showView('board-view');

  document.getElementById('board-title').textContent = boardNames[boardId] + " 게시판";

    const posts = await fetchPostsForBoard(boardId, page);
    const postList = document.getElementById('post-list');
    const formatDate = (timestamp) =>
        timestamp ? new Date(timestamp.seconds * 1000).toLocaleDateString('ko-KR') : '방금';

    postList.innerHTML =
        posts.map((post, index) => `
        <tr class="post-link" data-post-id="${post.id}" data-board="${post.board}">
            <td>${index + 1}</td>
            <td>${post.title} <span class="comment-count">[${post.commentCount || 0}]</span></td>
            <td>${post.authorName}</td>
            <td>${formatDate(post.createdAt)}</td>
            <td>${post.views || 0}</td>
            <td>${post.likes || 0}</td>
            <td>${post.dislikes || 0}</td>
        </tr>
    `).join('') || '<tr><td colspan="7">게시글이 없습니다.</td></tr>';
}

        // 추가: 글쓰기 폼 렌더링
        function renderWriteView() {
            const boardId = appState.currentBoard;
            if (!appState.currentUser) {
                alert("로그인이 필요합니다.");
                return;
            }
            showView('write-view');
            const writeView = document.getElementById('write-view');
            writeView.innerHTML = `
                <h2>${boardNames[boardId]} 글쓰기</h2>
                <form id="write-form">
                    <input type="text" id="write-title" placeholder="제목을 입력하세요" required>
                    <textarea id="write-content" placeholder="내용을 입력하세요" required></textarea>
                    <div class="form-actions">
                        <button type="button" id="cancel-write-btn" class="write-btn" style="background-color:#64748b;">취소</button>
                        <button type="submit" class="write-btn">등록</button>
                    </div>
                </form>
            `;
            // 이벤트 리스너 연결
            document.getElementById('write-form').addEventListener('submit', handlePostSubmit);
            document.getElementById('cancel-write-btn').addEventListener('click', () => renderBoardView(appState.currentBoard, 1));
        }

        // 추가: 게시물 보기 렌더링
  // ✅ 기존 renderPostView 함수를 아래 코드로 완전히 교체하세요.
async function renderPostView(boardId, postId) {
    showView('post-view');
    appState.currentPostId = postId; // 현재 게시물 ID 저장
    const postRef = doc(db, "posts", postId);
    
    // 조회수 1 증가
    await updateDoc(postRef, { views: increment(1) });
    
    const postSnap = await getDoc(postRef);

    if (postSnap.exists()) {
        const post = postSnap.data();
        const postView = document.getElementById('post-view');
        const formatDate = (timestamp) => timestamp ? new Date(timestamp.seconds * 1000).toLocaleString('ko-KR') : '';
        
        // 1. 게시물, 추천/비추천, 댓글 섹션의 기본 HTML 구조를 모두 그립니다.
        postView.innerHTML = `
            <div id="post-content-view">
                <h1>${post.title}</h1>
                <div id="post-meta">
                    <span>작성자: ${post.authorName}</span> | 
                    <span>작성일: ${formatDate(post.createdAt)}</span> |
                    <span>조회: ${post.views || 1}</span>
                </div>
                <div id="post-body">${post.content.replace(/\n/g, '<br>')}</div>

                <div id="vote-bar" style="display:flex; gap:.5rem; align-items:center; margin:1rem 0;">
                    <button id="like-btn" class="write-btn" style="background:#16a34a;">
                        👍 추천 <span id="like-count">${post.likes || 0}</span>
                    </button>
                    <button id="dislike-btn" class="write-btn" style="background:#ef4444;">
                        👎 비추천 <span id="dislike-count">${post.dislikes || 0}</span>
                    </button>
                </div>

                <button id="back-to-list-btn" class="write-btn">목록으로</button>
            </div>
            
            <div id="comments-section">
                <h3>댓글</h3>
                <ul id="comments-list"></ul>
                ${appState.currentUser ? `
                    <form id="comment-form" class="comment-form">
                        <textarea id="comment-text" placeholder="댓글을 입력하세요..." required></textarea>
                        <button type="submit" class="write-btn">등록</button>
                    </form>
                ` : `<p style="text-align:center; color:#64748b;">댓글을 작성하려면 로그인이 필요합니다.</p>`}
            </div>
        `;

        // --- 기능 실행 ---
        // 2. 추천/비추천 버튼에 이벤트 기능을 연결합니다. (이 부분이 누락되었습니다)
        setupVoteUI(postId);
        
        // 3. 댓글 목록을 불러옵니다.
        renderComments(postId);
        
        // --- 이벤트 리스너 연결 ---
        document.getElementById('back-to-list-btn').addEventListener('click', () => renderBoardView(boardId, 1));
        if (appState.currentUser) {
            document.getElementById('comment-form').addEventListener('submit', (e) => handleCommentSubmit(e, postId));
        }

    } else {
        alert("게시물을 찾을 수 없습니다.");
        renderBoardView(boardId, 1);
    }
}

        // renderPostView 함수 아래에 아래 함수들을 모두 추가하세요.

// === 댓글 기능 함수 START ===

// 댓글 렌더링 메인 함수
async function renderComments(postId) {
    const commentsList = document.getElementById('comments-list');
    commentsList.innerHTML = '<li>댓글을 불러오는 중...</li>';

    // 1. 모든 댓글을 가져와 ID를 키로 하는 맵으로 변환
    const commentsCol = collection(db, "posts", postId, "comments");
    const q = query(commentsCol, orderBy("createdAt"));
    const snapshot = await getDocs(q);
    
    const commentsMap = new Map();
    snapshot.docs.forEach(doc => {
        commentsMap.set(doc.id, { id: doc.id, children: [], ...doc.data() });
    });

    // 2. 부모-자식 관계를 구축
    const rootComments = [];
    commentsMap.forEach(comment => {
        if (comment.parentId && commentsMap.has(comment.parentId)) {
            commentsMap.get(comment.parentId).children.push(comment);
        } else {
            rootComments.push(comment);
        }
    });

    // 3. 최상위 댓글부터 재귀적으로 HTML 생성
    commentsList.innerHTML = '';
    if (rootComments.length === 0) {
        commentsList.innerHTML = '<li>작성된 댓글이 없습니다.</li>';
        return;
    }
    rootComments.forEach(comment => {
        const li = createCommentElement(comment);
        commentsList.appendChild(li);
    });
}

// 개별 댓글 엘리먼트(<li>)를 생성하는 재귀 함수
function createCommentElement(comment) {
    const li = document.createElement('li');
    li.className = 'comment-item';
    li.id = `comment-${comment.id}`;
    const formatDate = (ts) => ts ? new Date(ts.seconds * 1000).toLocaleString('ko-KR') : '';

    li.innerHTML = `
        <div class="comment-header">
            <span class="comment-author">${comment.authorName}</span>
            <span class="comment-date">${formatDate(comment.createdAt)}</span>
        </div>
        <p class="comment-body">${comment.text.replace(/\n/g, '<br>')}</p>
        <div class="comment-actions">
            ${appState.currentUser ? `<button class="reply-btn" data-comment-id="${comment.id}">답글 달기</button>` : ''}
        </div>
    `;

    // 답글(자식 댓글)이 있으면 재귀적으로 처리
    if (comment.children.length > 0) {
        const replyList = document.createElement('ul');
        replyList.className = 'reply-list';
        comment.children.forEach(reply => {
            replyList.appendChild(createCommentElement(reply));
        });
        li.appendChild(replyList);
    }
    
    // '답글 달기' 버튼에 이벤트 리스너 추가
    li.querySelector('.reply-btn')?.addEventListener('click', showReplyForm);

    return li;
}

// 답글 폼을 보여주는 함수
function showReplyForm(e) {
    const parentCommentId = e.target.dataset.commentId;
    const parentCommentItem = document.getElementById(`comment-${parentCommentId}`);

    // 이미 답글 폼이 있다면 제거
    const existingForm = parentCommentItem.querySelector('.reply-form-container');
    if (existingForm) {
        existingForm.remove();
        return;
    }
    
    const formContainer = document.createElement('div');
    formContainer.className = 'reply-form-container';
    formContainer.innerHTML = `
        <form class="comment-form reply-form">
            <textarea placeholder="답글을 입력하세요..." required></textarea>
            <button type="submit" class="write-btn">등록</button>
        </form>
    `;

    // 생성된 폼의 submit 이벤트 처리
    formContainer.querySelector('.reply-form').addEventListener('submit', (event) => {
        handleCommentSubmit(event, appState.currentPostId, parentCommentId);
    });

    parentCommentItem.appendChild(formContainer);
    formContainer.querySelector('textarea').focus();
}

// 댓글/답글 제출 처리 함수
// ✅ handleCommentSubmit 함수를 아래 코드로 수정하세요.
async function handleCommentSubmit(e, postId, parentId = null) {
    e.preventDefault();
    const user = appState.currentUser;
    if (!user) {
        alert("로그인이 필요합니다.");
        return;
    }

    const textarea = e.target.querySelector('textarea');
    const text = textarea.value.trim();
    if (!text) return;

    try {
        // 댓글 데이터 추가
        const commentsCol = collection(db, "posts", postId, "comments");
        const commentData = {
            text: text,
            authorId: user.uid,
            authorName: user.nickname,
            createdAt: serverTimestamp(),
        };
        if (parentId) {
            commentData.parentId = parentId;
        }
        await addDoc(commentsCol, commentData);

        // ✅ 추가: 게시물의 commentCount 필드 1 증가
        const postRef = doc(db, "posts", postId);
        await updateDoc(postRef, { commentCount: increment(1) });
        
        // UI 갱신
        textarea.value = '';
        const formContainer = e.target.closest('.reply-form-container');
        if(formContainer) formContainer.remove();
        renderComments(postId);

    } catch (error) {
        console.error("댓글 등록 오류: ", error);
        alert("댓글 등록에 실패했습니다.");
    }
}

// === 댓글 기능 함수 END ===


        async function setupVoteUI(postId) {
  const likeBtn = document.getElementById('like-btn');
  const dislikeBtn = document.getElementById('dislike-btn');

  likeBtn.addEventListener('click', () => handleVote(postId, 1));
  dislikeBtn.addEventListener('click', () => handleVote(postId, -1));

  // 로그인 안됐으면 상태표시 생략
  const user = appState.currentUser;
  if (!user) return;

  const voteRef = doc(db, "posts", postId, "votes", user.uid);
  const snap = await getDoc(voteRef);
  if (snap.exists()) {
    const v = snap.data().value;
    if (v === 1) likeBtn.style.outline = "3px solid rgba(34,197,94,.4)";
    if (v === -1) dislikeBtn.style.outline = "3px solid rgba(239,68,68,.4)";
  }
}

// ✅ 트랜잭션으로 추천/비추천 처리 (단일계정 1표, 취소/전환 지원)
async function handleVote(postId, value) {
  // value: 1=추천, -1=비추천
  const user = appState.currentUser;
  if (!user) { alert("로그인이 필요합니다."); return; }

  const postRef = doc(db, "posts", postId);
  const voteRef = doc(db, "posts", postId, "votes", user.uid);

  try {
    await runTransaction(db, async (tx) => {
      const [postSnap, voteSnap] = await Promise.all([tx.get(postRef), tx.get(voteRef)]);
      if (!postSnap.exists()) throw new Error("게시물 없음");

      let likes = postSnap.data().likes || 0;
      let dislikes = postSnap.data().dislikes || 0;

      if (!voteSnap.exists()) {
        // 첫 투표
        if (value === 1) likes += 1;
        else dislikes += 1;
        tx.set(voteRef, { value, createdAt: serverTimestamp() });
      } else {
        const prev = voteSnap.data().value; // 1 or -1
        if (prev === value) {
          // 같은 쪽 재클릭 = 취소
          if (value === 1) likes -= 1;
          else dislikes -= 1;
          tx.delete(voteRef);
        } else {
          // 방향 전환
          if (value === 1) { likes += 1; dislikes -= 1; }
          else { dislikes += 1; likes -= 1; }
          tx.update(voteRef, { value, createdAt: serverTimestamp() });
        }
      }

      tx.update(postRef, { likes, dislikes });
    });

    // 화면 카운트 갱신
    const latest = (await getDoc(postRef)).data();
    document.getElementById('like-count').textContent = latest.likes || 0;
    document.getElementById('dislike-count').textContent = latest.dislikes || 0;

    // 버튼 하이라이트 갱신
    const likeBtn = document.getElementById('like-btn');
    const dislikeBtn = document.getElementById('dislike-btn');
    likeBtn.style.outline = "";
    dislikeBtn.style.outline = "";

    const myVote = await getDoc(doc(db, "posts", postId, "votes", appState.currentUser.uid));
    if (myVote.exists()) {
      if (myVote.data().value === 1) likeBtn.style.outline = "3px solid rgba(34,197,94,.4)";
      if (myVote.data().value === -1) dislikeBtn.style.outline = "3px solid rgba(239,68,68,.4)";
    }

  } catch (e) {
    console.error(e);
    alert("투표 처리 중 오류가 발생했습니다.");
  }
}
        
        // === 이벤트 핸들러 ===

        // 추가: 글쓰기 제출 핸들러
// ✅ handlePostSubmit 함수를 아래 코드로 수정하세요.
async function handlePostSubmit(e) {
    e.preventDefault();
    const title = document.getElementById('write-title').value;
    const content = document.getElementById('write-content').value;
    const user = appState.currentUser;

    if (!user) {
        alert("로그인이 필요합니다.");
        return;
    }

    try {
        const postsCol = collection(db, 'posts');
        await addDoc(postsCol, {
            title,
            content,
            authorId: user.uid,
            authorName: user.nickname,
            board: appState.currentBoard,
            createdAt: serverTimestamp(),
            views: 0,
            likes: 0,
            dislikes: 0,
            commentCount: 0, // ✅ 추가: 댓글 카운터 초기화
            comments: [] // 이 필드는 더 이상 사용하지 않지만 호환성을 위해 유지
        });
        
        const siteStatsDocRef = doc(db, 'siteStats', 'summary');
        await setDoc(siteStatsDocRef, { totalPosts: increment(1) }, { merge: true });

        alert("게시물이 등록되었습니다.");
        renderBoardView(appState.currentBoard, 1);

    } catch (error) {
        console.error("게시물 등록 오류: ", error);
        alert("게시물 등록에 실패했습니다.");
    }
}
        
        // --- AUTHENTICATION LOGIC ---
        const userMenuContainer = document.getElementById('user-menu-container');
        const loginModal = document.getElementById('login-modal');
        const signupModal = document.getElementById('signup-modal');

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                const userDocRef = doc(db, "users", user.uid);
                const userDoc = await getDoc(userDocRef);
                const nickname = userDoc.exists() ? userDoc.data().nickname : user.email.split('@')[0];
                
                appState.currentUser = { uid: user.uid, email: user.email, nickname: nickname };

                userMenuContainer.innerHTML = `
                    <span>${nickname}님</span>
                    <button id="logout-btn">로그아웃</button>
                `;
                document.getElementById('logout-btn').addEventListener('click', () => signOut(auth));
            } else {
                appState.currentUser = null;
                userMenuContainer.innerHTML = `
                    <a href="#" id="login-btn">로그인</a>
                    <a href="#" id="signup-btn">회원가입</a>
                `;
                document.getElementById('login-btn').addEventListener('click', (e) => { e.preventDefault(); loginModal.classList.add('show'); });
                document.getElementById('signup-btn').addEventListener('click', (e) => { e.preventDefault(); signupModal.classList.add('show'); });
            }
        });
        
        // 회원가입 폼
        document.getElementById('signup-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const nickname = document.getElementById('signup-nickname').value;
            const email = document.getElementById('signup-email').value;
            const password = document.getElementById('signup-password').value;

            try {
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                const user = userCredential.user;
                await updateProfile(user, { displayName: nickname });
                await setDoc(doc(db, "users", user.uid), { nickname: nickname, email: email });
                alert('회원가입이 완료되었습니다! 이제 로그인해주세요.');
                signupModal.classList.remove('show');
            } catch (error) { alert(`회원가입 실패: ${error.message}`); }
        });

        // 로그인 폼
        document.getElementById('login-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = document.getElementById('login-email').value;
            const password = document.getElementById('login-password').value;
            try {
                await signInWithEmailAndPassword(auth, email, password);
                loginModal.classList.remove('show');
            } catch (error) { alert(`로그인 실패: ${error.message}`); }
        });

        // --- GLOBAL EVENT LISTENERS ---
        document.querySelectorAll('.modal-overlay').forEach(modal => {
            modal.addEventListener('click', (e) => { if (e.target === modal) modal.classList.remove('show'); });
        });
        document.querySelectorAll('.modal-close-btn').forEach(btn => {
            btn.addEventListener('click', () => { btn.closest('.modal-overlay').classList.remove('show'); });
        });

        const sportsGalleryToggle = document.getElementById('sports-gallery-toggle');
        const sportsGalleryDropdown = document.getElementById('sports-gallery-dropdown');

        sportsGalleryToggle.addEventListener('click', (e) => {
            e.preventDefault();
            sportsGalleryDropdown.classList.toggle('show');
        });

        document.addEventListener('click', (e) => {
            if (!document.getElementById('sports-gallery-menu').contains(e.target)) {
                sportsGalleryDropdown.classList.remove('show');
            }
        });

        document.getElementById('app').addEventListener('click', (e) => {
            const navLink = e.target.closest('.nav-link');
            if (navLink && navLink.dataset.board) {
                e.preventDefault();
                renderBoardView(navLink.dataset.board, 1);
                sportsGalleryDropdown.classList.remove('show');
                return;
            }

            const postLink = e.target.closest('.post-link');
            if (postLink) {
                e.preventDefault();
                const postId = postLink.dataset.postId;
                const boardId = postLink.dataset.board;
                renderPostView(boardId, postId);
                return;
            }
        });

        document.getElementById('logo').addEventListener('click', renderMainView);
        document.getElementById('write-post-btn').addEventListener('click', renderWriteView);
        
        // Initial Render
        renderMainView();
    </script>
</body>
</html>